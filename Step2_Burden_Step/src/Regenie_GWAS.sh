#!/bin/bash
# Regenie_GWAS 0.0.01
# Generated by dx-app-wizard.
#
# Basic execution pattern: Your app will run on a single machine from
# beginning to end.
#
# Your job's input variables (if any) will be loaded as environment
# variables before this script runs.  Any array inputs will be loaded
# as bash arrays.
#
# Any code outside of main() (or any entry point you may add) is
# ALWAYS executed, followed by running the entry point itself.
#
# See https://documentation.dnanexus.com/developer for tutorials on how
# to modify this file.

main() {
    # The following line(s) use the dx command-line tool to download your file
    # inputs to the local file system using variable names for the filenames. To
    # recover the original filenames, you can use the output of "dx describe
    # "$variable" --name".
    project="project-GbZ9g7QJVJzZVQj45j6xgxZ8"
    range="${chrom_start}_${chrom_end}"
    type="Continuous"
    echo "############ Download phenotype files ############"
    basic_files
    echo "############ Setting up environment ############"
    setup 
    echo "############ Check if this job has already been done ############"
    check_done

    if [[ ${already_done} -eq 0 ]]; then

    	echo "############ Downloading WGS files ############"
    	download_files
    	echo "############ Setting up masks ############"
    	mask_setup
    	echo "############ Setting up conditional files ############"
    	conditional_lists
    	echo "############ Checking if chunk (first regenie) has already been run ############"
    	check_chunk

    	echo "############ Running aggregates adjusted for common variants ############"
    	if [ ${already_run_regenie} -eq 0 ]; then
    		run_first_regenie
    		dx upload ${outputdir}/*.regenie --path ${project}:proteomics/results/${outputdir}/
    		dx upload ${outputdir}/*.log --path ${project}:proteomics/results/${outputdir}/
    	fi
    #dx upload ${outputdir}/*.regenie --path ${project}:proteomics/results/${outputdir}/
    #dx upload ${outputdir}/*.log --path ${project}:proteomics/results/${outputdir}/

    	if [ ${n_sig_sets} -gt 0 ];then
		echo "Running significant hits again"
		run_significant_hits_again
		echo "Identifying independent signals"
    		aggregate_conditioning
    	
        	rm ${outputdir}/*burden_${Phenotype}.regenie
		#rm ${outputdir}/*burden_${Phenotype}.log

    		dx upload ${outputdir}/*.regenie --path ${project}:proteomics/results/${outputdir}/
    		dx upload ${outputdir}/*.log --path ${project}:proteomics/results/${outputdir}/
    	fi
    else
	    echo "Nothing to do for this chunk"
    fi
    #### Nonsense output 
    dx-jobutil-add-output output "$output" --class=string
}


check_done() {


touch ${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_unconditional_${Phenotype}.regenie  # create a temporary file to bypass dx's ridiculous erroring
  dx upload ${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_unconditional_${Phenotype}.regenie --path=${project}:proteomics/results/${outputdir}/
  files=`dx ls ${project}:proteomics/results/${outputdir}/${Phenotype}_chr${chr}_${range}_masks_*_chr_${chr}_burden_unconditional_${Phenotype}.regenie` # check which files exist
  dx rm -a ${project}:proteomics/results/${outputdir}/${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_unconditional_${Phenotype}.regenie
  rm ${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_unconditional_${Phenotype}.regenie
  already_done=0 # flag to check if this chunk has already run, and skip if so (this will enable the pipeline to be resubmitted if it fails part way through)
  for file in $files # check if this chunk's output file exists
  do
    if [[ $file == ${Phenotype}_chr${chr}_${range}_masks_3_chr_${chr}_burden_unconditional_${Phenotype}.regenie ]]
    then
      already_done=1
    elif [[ $file == ${Phenotype}_chr${chr}_${range}_masks_2_chr_${chr}_burden_unconditional_${Phenotype}.regenie ]]
    then
      already_done=1
    elif [[ $file == ${Phenotype}_chr${chr}_${range}_masks_1_chr_${chr}_burden_unconditional_${Phenotype}.regenie ]]
    then
      already_done=1
    fi
   done

}


check_chunk() {
    touch ${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_${Phenotype}.regenie  # create a temporary file to bypass dx's ridiculous erroring
  dx upload ${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_${Phenotype}.regenie --path=${project}:proteomics/results/${outputdir}/
  files=`dx ls ${project}:proteomics/results/${outputdir}/${Phenotype}_chr${chr}_${range}_masks_*_chr_${chr}_burden_${Phenotype}.regenie` # check which files exist
  dx rm -a ${project}:proteomics/results/${outputdir}/${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_${Phenotype}.regenie
  rm ${Phenotype}_chr${chr}_${range}_masks_XYZ_chr_${chr}_burden_${Phenotype}.regenie
  already_run_regenie=0 # flag to check if this chunk has already run, and skip if so (this will enable the pipeline to be resubmitted if it fails part way through)
  for file in $files # check if this chunk's output file exists
  do
    if [[ $file == ${Phenotype}_chr${chr}_${range}_masks_3_chr_${chr}_burden_${Phenotype}.regenie ]]
    then
      already_run_regenie=1
      dx download ${project}:proteomics/results/${outputdir}/${Phenotype}_chr${chr}_${range}_masks_*_chr_${chr}_burden_${Phenotype}.regenie --overwrite
      mv ${Phenotype}_chr${chr}_${range}_masks_*_chr_${chr}_burden_${Phenotype}.regenie ./${outputdir}/

      grep -vE -h --no-filename '#|CHROM' ${outputdir}/*.regenie | awk '$12>=8.06 {print}' |  cut -d' ' -f3 | cut -d'.' -f1 | cat > sets_for_second_round 
    cat sets_for_second_round <(echo "second_round") > sets_for_second_round_count
    
    n_sig_sets=`wc -l sets_for_second_round_count | cut -d' ' -f1`
    n_sig_sets=$((${n_sig_sets}-1))
    n_assocs=0
    if [ ${n_sig_sets} -gt 0 ]; then
	grep -wf sets_for_second_round set_list_temp | cat > set_list_temp_mv
        mv set_list_temp_mv set_list_temp

	# top set details 
	grep -vE -h --no-filename '#|CHROM' ${outputdir}/*.regenie | sort -k12 -gr | head -n 1 > top_sets_temp
	top_hit=`cut -d' ' -f3 top_sets_temp`
	top_test=`cut -d' ' -f8 top_sets_temp`
	top_set=`cut -d' ' -f3 top_sets_temp | cut -d'.' -f1`
	top_mask=`cut -d' ' -f3 top_sets_temp | cut -d'.' -f2`
	top_consq=`grep -w ${top_mask} all_masks  | cut -f2 | sed 's/\,/\|/g'`
	 

	grep -vE -h --no-filename '#|CHROM' ${outputdir}/*.regenie | awk '$12>=8.06 {print}' | grep -vw 'ADD-BURDEN-ACAT' |   cut -d' ' -f3 | awk -F'[\.]' '{print $1"."$2}' |  awk '!seen[$1]++ {print}' |  cat > assocs_for_second_round
        cat assocs_for_second_round <(echo "second_round") >  assocs_for_second_round_count
        n_assocs=`wc -l assocs_for_second_round_count | cut -d' ' -f1`
        n_assocs=$((${n_assocs}-2))


  	grep -E 'regulatory|sliding|rna' set_list_temp | cat > set_list_only_reg_count
	echo "reg sets" >> set_list_only_reg_count
  	n_reg_sets=`wc -l set_list_only_reg_count | cut -d' ' -f1`
  	n_reg_sets=$((${n_reg_sets}-1))

  	echo $((${n_reg_sets})) " regulatory and sliding window sets to run again"

  	
	grep -E -v 'regulatory|sliding|rna' set_list_temp | cut -f1 |  cat > set_list_not_reg_count

	grep -wf set_list_not_reg_count annotations_coding_proximal_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}'  | cat  > annots_temp_codprox_top_sets
	grep -wf annots_temp_codprox_top_sets <(cut -f2 masks_2_chr_${chr} | sed 's/\,/\n/g') | cat > annots_to_run_top_set_coding_proximal 

  	echo "nonreg sets" >> annots_to_run_top_set_coding_proximal
  	n_nonreg_sets=`wc -l annots_to_run_top_set_coding_proximal | cut -d' ' -f1`
  	n_nonreg_sets=$((${n_nonreg_sets}-1))

  	echo $((${n_nonreg_sets})) " coding and proximal annotations to run again"


	grep -E -v 'regulatory|sliding|rna|coding' set_list_temp | cut -f1 | cat > set_list_not_reg_not_cod_count
	grep -wf set_list_not_reg_not_cod_count annotations_utr_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}' | cat > annots_temp_utr_top_sets
	grep -wf annots_temp_utr_top_sets <(cut -f2 masks_3_chr_${chr} | sed 's/\,/\n/g') | cat > annots_to_run_top_set_utr

        echo "nonregcod sets" >> annots_to_run_top_set_utr
        n_nonregnoncod_sets=`wc -l annots_to_run_top_set_utr | cut -d' ' -f1`
        n_nonregnoncod_sets=$((${n_nonregnoncod_sets}-1))

        echo $((${n_nonregnoncod_sets})) " UTR and extra proximal annotations to run again"
  	fi
  fi
  done


}



run_first_regenie() {
    # run regenie using xargs to run 2 jobs at once
    com=""
    if [ ${n_reg_sets} -gt 0 ];then
      com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps masks_1_chr_${chr} annotations_regulatory_chr${chr} 0.001 $invnorm common $type ${range}"
    fi
    if [ ${n_nonreg_sets} -gt 0 ];then
      #coding proximal 
      com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps masks_2_chr_${chr} annotations_coding_proximal_chr${chr} 0.001 $invnorm common $type ${range}"
      #utrs 
      com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps masks_3_chr_${chr} annotations_utr_chr${chr} 0.001 $invnorm common $type ${range}"
    fi
    echo ${com}
    echo $com | xargs -n 12 -P 3 bash -c 'bash run_step2_regenie.sh "$@"' _

    grep -vE -h --no-filename '#|CHROM' ${outputdir}/*.regenie | awk '$12>=8.06 {print}' |  cut -d' ' -f3 | cut -d'.' -f1 | cat > sets_for_second_round 
    cat sets_for_second_round <(echo "second_round") > sets_for_second_round_count
    
    n_sig_sets=`wc -l sets_for_second_round_count | cut -d' ' -f1`
    n_sig_sets=$((${n_sig_sets}-1))
    n_assocs=0

    if [ ${n_sig_sets} -gt 0 ]; then
	grep -wf sets_for_second_round set_list_temp | cat > set_list_temp_mv
        mv set_list_temp_mv set_list_temp

	# top set details 

	grep -vE -h --no-filename '#|CHROM' ${outputdir}/*.regenie | sort -k12 -gr | head -n 1 > top_sets_temp
	top_hit=`cut -d' ' -f3 top_sets_temp`
	top_test=`cut -d' ' -f8 top_sets_temp`
	top_set=`cut -d' ' -f3 top_sets_temp | cut -d'.' -f1`
	top_mask=`cut -d' ' -f3 top_sets_temp | cut -d'.' -f2`
	top_consq=`grep -w ${top_mask} all_masks  | cut -f2 | sed 's/\,/\|/g'`


	grep -vE -h --no-filename '#|CHROM' ${outputdir}/*.regenie | awk '$12>=8.06 {print}' | grep -vw 'ADD-BURDEN-ACAT' |   cut -d' ' -f3 | awk -F'[\.]' '{print $1"."$2}' |  awk '!seen[$1]++ {print}' |  cat > assocs_for_second_round
        cat assocs_for_second_round <(echo "second_round") >  assocs_for_second_round_count
        n_assocs=`wc -l assocs_for_second_round_count | cut -d' ' -f1`
        n_assocs=$((${n_assocs}-2))
	 
	# number of sets for next step

        grep -E 'regulatory|sliding|rna' set_list_temp | cat > set_list_only_reg_count
	echo "reg sets" >> set_list_only_reg_count
        n_reg_sets=`wc -l set_list_only_reg_count | cut -d' ' -f1`
        n_reg_sets=$((${n_reg_sets}-1))

        echo $((${n_reg_sets})) " regulatory and sliding window sets to run again"


        grep -E -v 'regulatory|sliding|rna' set_list_temp | cut -f1 |  cat > set_list_not_reg_count

        grep -wf set_list_not_reg_count annotations_coding_proximal_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}'  | cat  > annots_temp_codprox_top_sets
        grep -wf annots_temp_codprox_top_sets <(cut -f2 masks_2_chr_${chr} | sed 's/\,/\n/g') | cat > annots_to_run_top_set_coding_proximal

        echo "nonreg sets" >> annots_to_run_top_set_coding_proximal
        n_nonreg_sets=`wc -l annots_to_run_top_set_coding_proximal | cut -d' ' -f1`
        n_nonreg_sets=$((${n_nonreg_sets}-1))

        echo $((${n_nonreg_sets})) " coding and proximal annotations to run again"


        grep -E -v 'regulatory|sliding|rna|coding' set_list_temp | cut -f1 | cat > set_list_not_reg_not_cod_count
        grep -wf set_list_not_reg_not_cod_count annotations_utr_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}' | cat > annots_temp_utr_top_sets
        grep -wf annots_temp_utr_top_sets <(cut -f2 masks_3_chr_${chr} | sed 's/\,/\n/g') | cat > annots_to_run_top_set_utr

        echo "nonregcod sets" >> annots_to_run_top_set_utr
        n_nonregnoncod_sets=`wc -l annots_to_run_top_set_utr | cut -d' ' -f1`
        n_nonregnoncod_sets=$((${n_nonregnoncod_sets}-1))

        echo $((${n_nonregnoncod_sets})) " UTR and extra proximal annotations to run again"
  fi 

}

aggregate_conditioning() {


    if [ ${n_sig_sets} -gt 0 ]  && [ ${n_assocs} -eq 0 ]; then
	     awk -v r=${range} -v c=${count} -v s=${start_region} -v e=${end_region} -v n=${nvars} -v l=${log10p_raw}  '{print $0,r,c,s,e,n,l}' top_sets_temp >> ${outputdir}/${Phenotype}_chr${chr}_${range}_independent_aggregates.regenie
    fi

    grep -vE -h --no-filename '#|CHROM' ${outputdir}/*.regenie | awk '$12>=8.06 {print}' | grep -vw 'ADD-BURDEN-ACAT' |   cut -d' ' -f3 | awk -F'[\.]' '{print $1"."$2}' |  awk '!seen[$1]++ {print}' | grep -v "${top_set}.${top_mask}" |  cat > assocs_for_second_round
        cat assocs_for_second_round <(echo "second_round") >  assocs_for_second_round_count
        n_assocs=`wc -l assocs_for_second_round_count | cut -d' ' -f1`
        n_assocs=$((${n_assocs}-1))

	cut -d'.' -f2 assocs_for_second_round > masks_for_second_round

        grep -E 'regulatory|sliding|rna' set_list_temp | cut -f1 | cat > set_list_only_reg
        grep -of set_list_only_reg assocs_for_second_round  | cat  > set_list_only_reg_count
        echo "reg sets" >> set_list_only_reg_count
        n_reg_sets=`wc -l set_list_only_reg_count | cut -d' ' -f1`
        n_reg_sets=$((${n_reg_sets}-1))

        echo $((${n_reg_sets})) " regulatory and sliding window sets to run again"


        grep -E -v 'regulatory|sliding|rna' set_list_temp | cut -f1 |  cat > set_list_not_reg

        grep -of set_list_not_reg assocs_for_second_round  | cat  > set_list_not_reg_count

        grep -wf set_list_not_reg_count annotations_coding_proximal_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}'  | cat  > annots_temp_codprox_top_sets
        grep -wf annots_temp_codprox_top_sets <(grep -wf masks_for_second_round  masks_2_chr_${chr} | cut -f2 |  sed 's/\,/\n/g') | cat > annots_to_run_top_set_coding_proximal

        echo "nonreg sets" >> annots_to_run_top_set_coding_proximal
        n_nonreg_sets=`wc -l annots_to_run_top_set_coding_proximal | cut -d' ' -f1`
        n_nonreg_sets=$((${n_nonreg_sets}-1))

        echo $((${n_nonreg_sets})) " coding and proximal annotations to run again"


        grep -E -v 'regulatory|sliding|rna|coding' set_list_temp | cut -f1 | cat > set_list_not_reg_not_cod
        grep -of set_list_not_reg_not_cod assocs_for_second_round | cat  > set_list_not_reg_not_cod_count

        grep -wf set_list_not_reg_not_cod_count annotations_utr_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}' | cat > annots_temp_utr_top_sets
        grep -wf annots_temp_utr_top_sets <(grep -wf masks_for_second_round  masks_3_chr_${chr} | cut -f2  | sed 's/\,/\n/g') | cat > annots_to_run_top_set_utr

        echo "nonregcod sets" >> annots_to_run_top_set_utr
        n_nonregnoncod_sets=`wc -l annots_to_run_top_set_utr | cut -d' ' -f1`
        n_nonregnoncod_sets=$((${n_nonregnoncod_sets}-1))

        echo $((${n_nonregnoncod_sets})) " UTR and extra proximal annotations to run again"
        #get top hit again



    count=0
    while [ ${n_assocs} -gt 0 ]; do
	### get variants from top hit
	grep -w -h --no-filename "${top_set}" annotations_coding_proximal_chr${chr} | grep -wE "${top_consq}" |  cut -f1 | sort -k1 | uniq | cat  > conditional_list_top_set_temp
	grep -w -h --no-filename "${top_set}" annotations_regulatory_chr${chr} | grep -wE "${top_consq}" |  cut -f1 | sort -k1 | uniq | cat  >> conditional_list_top_set_temp
	grep -w -h --no-filename "${top_set}" annotations_utr_chr${chr} | grep -wE "${top_consq}" |  cut -f1 | sort -k1 | uniq | cat  >> conditional_list_top_set_temp
	./plink2 --pfile chr${chr}_sv_and_snv --extract conditional_list_top_set_temp --max-maf 0.005 --make-bed --out temp_plink_top_test
       
       nvars=`wc -l temp_plink_top_test.bim | cut -d' ' -f1`
       start_region=`head -n 1 temp_plink_top_test.bim | cut -f4`
       if [ ${nvars} -gt 9999 ]; then
	       echo  "Too many variants to condition on - conditioning step halted"
	       echo "Too many variants to condition on - conditioning step halted" >> ${outputdir}/${Phenotype}_chr${chr}_${range}_independent_aggregates.regenie
	      break
       fi
       end_region=`tail -n 1 temp_plink_top_test.bim | cut -f4`
       log10p_raw=`grep -w -h --no-filename "${top_hit}" ${outputdir}/${Phenotype}_chr${chr}_${range}_masks_*_chr_${chr}_burden_${Phenotype}.regenie | grep -w "${top_test}" | head -n 1 | cut -d' ' -f12` 

       awk -v r=${range} -v c=${count} -v s=${start_region} -v e=${end_region} -v n=${nvars} -v l=${log10p_raw}  '{print $0,r,c,s,e,n,l}' top_sets_temp >> ${outputdir}/${Phenotype}_chr${chr}_${range}_independent_aggregates.regenie
       
       cut -f2 temp_plink_top_test.bim | cat  > variants_for_conditioning_top_test  
       #add them to the conditional list
       cat conditional_list_local variants_for_conditioning_top_test > conditional_list_local_mv
       mv conditional_list_local_mv conditional_list_local

	echo "conditional" >> conditional_list_local
   	n_conditional_snps=`wc -l conditional_list_local | cut -d' ' -f1`
    	n_conditional_snps=$((${n_conditional_snps}-1))
    	grep -wv "conditional" conditional_list_local | cat > conditional_list_local_mv
    	mv conditional_list_local_mv conditional_list_local

	com=""
    	

	#run sig hits conditional on top hit

	if [ ${n_reg_sets} -gt 0 ];then
      		com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps masks_1_chr_${chr} annotations_regulatory_chr${chr} 0.001 $invnorm common $type conditioning_step${count}_${range}"
    	fi
    	if [ ${n_nonreg_sets} -gt 0 ];then
		#coding proximal
      		com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps masks_2_chr_${chr} annotations_coding_proximal_chr${chr} 0.001 $invnorm common $type conditioning_step${count}_${range}"
	fi
	if [ ${n_nonregnoncod_sets} -gt 0 ];then
		#utrs
		com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps masks_3_chr_${chr} annotations_utr_chr${chr} 0.001 $invnorm common $type conditioning_step${count}_${range}"
    	fi
    	echo ${com}
    	echo $com | xargs -n 12 -P 1 bash -c 'bash run_step2_regenie.sh "$@"' _

	#look for hits that remain (note slightly higher log10p thresh)

	grep -vE -h --no-filename '#|CHROM' ${outputdir}/*conditioning_step${count}_*.regenie | awk '$12>=7 {print}' |  cut -d' ' -f3 | cut -d'.' -f1 | cat > sets_for_second_round
    	cat sets_for_second_round <(echo "second_round") > sets_for_second_round_count

    	n_sig_sets=`wc -l sets_for_second_round_count | cut -d' ' -f1`
    	n_sig_sets=$((${n_sig_sets}-1))
	n_assocs=0

    if [ ${n_sig_sets} -gt 0 ]; then
        grep -wf sets_for_second_round set_list_temp | cat > set_list_temp_mv
        mv set_list_temp_mv set_list_temp


	grep -vE -h --no-filename '#|CHROM' ${outputdir}/*conditioning_step${count}_*.regenie | sort -k12 -gr | head -n 1 > top_sets_temp

        top_hit=`cut -d' ' -f3 top_sets_temp`
        top_test=`cut -d' ' -f8 top_sets_temp`
        top_set=`cut -d' ' -f3 top_sets_temp | cut -d'.' -f1`
        top_mask=`cut -d' ' -f3 top_sets_temp | cut -d'.' -f2`
        top_consq=`grep -w ${top_mask} all_masks  | cut -f2 | sed 's/\,/\|/g'`
	

	grep -vE -h --no-filename '#|CHROM' ${outputdir}/*conditioning_step${count}_*.regenie | awk '$12>=8.06 {print}' | grep -vw 'ADD-BURDEN-ACAT' |   cut -d' ' -f3 | awk -F'[\.]' '{print $1"."$2}' |  awk '!seen[$1]++ {print}' | grep -v "${top_set}.${top_mask}" |  cat > assocs_for_second_round
        cat assocs_for_second_round <(echo "second_round") >  assocs_for_second_round_count
        n_assocs=`wc -l assocs_for_second_round_count | cut -d' ' -f1`
        n_assocs=$((${n_assocs}-1))

	cut -d'.' -f2 assocs_for_second_round > masks_for_second_round

        grep -E 'regulatory|sliding|rna' set_list_temp | cut -f1 | cat > set_list_only_reg
        grep -of set_list_only_reg assocs_for_second_round  | cat  > set_list_only_reg_count
        echo "reg sets" >> set_list_only_reg_count
        n_reg_sets=`wc -l set_list_only_reg_count | cut -d' ' -f1`
        n_reg_sets=$((${n_reg_sets}-1))

        echo $((${n_reg_sets})) " regulatory and sliding window sets to run again"


        grep -E -v 'regulatory|sliding|rna' set_list_temp | cut -f1 |  cat > set_list_not_reg

        grep -of set_list_not_reg assocs_for_second_round  | cat  > set_list_not_reg_count

        grep -wf set_list_not_reg_count annotations_coding_proximal_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}'  | cat  > annots_temp_codprox_top_sets
        grep -wf annots_temp_codprox_top_sets <(grep -wf masks_for_second_round  masks_2_chr_${chr} | cut -f2 |  sed 's/\,/\n/g') | cat > annots_to_run_top_set_coding_proximal

        echo "nonreg sets" >> annots_to_run_top_set_coding_proximal
        n_nonreg_sets=`wc -l annots_to_run_top_set_coding_proximal | cut -d' ' -f1`
        n_nonreg_sets=$((${n_nonreg_sets}-1))

        echo $((${n_nonreg_sets})) " coding and proximal annotations to run again"


        grep -E -v 'regulatory|sliding|rna|coding' set_list_temp | cut -f1 | cat > set_list_not_reg_not_cod
        grep -of set_list_not_reg_not_cod assocs_for_second_round | cat  > set_list_not_reg_not_cod_count

        grep -wf set_list_not_reg_not_cod_count annotations_utr_chr${chr} | cut -f3 | awk '!seen[$1]++ {print}' | cat > annots_temp_utr_top_sets
        grep -wf annots_temp_utr_top_sets <(grep -wf masks_for_second_round masks_3_chr_${chr} | cut -f2 | sed 's/\,/\n/g') | cat > annots_to_run_top_set_utr

        echo "nonregcod sets" >> annots_to_run_top_set_utr
        n_nonregnoncod_sets=`wc -l annots_to_run_top_set_utr | cut -d' ' -f1`
        n_nonregnoncod_sets=$((${n_nonregnoncod_sets}-1))

        echo $((${n_nonregnoncod_sets})) " UTR and extra proximal annotations to run again"
	#get top hit again

    
    count=$((${count}+1))
    fi
    done
}



run_significant_hits_again() {
  # run regenie using xargs to run 2 jobs at once
    com=""
    if [ ${n_reg_sets} -gt 0 ];then
      com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps_all masks_1_chr_${chr} annotations_regulatory_chr${chr} 0.001 $invnorm all $type ${range}"
    fi
    if [ ${n_nonreg_sets} -gt 0 ];then
      #coding proximal
      com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps_all masks_2_chr_${chr} annotations_coding_proximal_chr${chr} 0.001 $invnorm all $type ${range}"
     fi
     if [ ${n_nonregnoncod_sets} -gt 0 ];then
      #utrs
      com="${com} $Phenotype $catvars $outputdir ${chr} $n_conditional_snps_all masks_3_chr_${chr} annotations_utr_chr${chr} 0.001 $invnorm all $type ${range}"
    fi
    echo ${com}
    echo $com | xargs -n 12 -P 3 bash -c 'bash run_step2_regenie.sh "$@"' _
}

basic_files() {
  #### Download input files
  dx download "$Covariate_TSV" -o Covariate_TSV.gz
  dx download "$Phenotype_TSV" -o Phenotype_TSV.gz
  
  touch conditional_list_common

  #### Unzip Pheno and Covar Files
  gunzip Covariate_TSV.gz
  sed -i 's/\.b/NA/g' Covariate_TSV
  gunzip Phenotype_TSV.gz
  sed -i 's/\.b/NA/g' Phenotype_TSV

  Phenotype=$(awk 'NR == 1 {print $3}' Phenotype_TSV)
  echo ${Phenotype}
}

download_files() {


  #### Download the chromosome file
  dx download ${project}":/proteomics/pgens/chr${chr}_*"
  ###Download Annotations and Masks
  dx download ${project}:/wgs_500k_masks/annotations_regulatory_chr${chr}
  dx download ${project}:/wgs_500k_masks/annotations_coding_proximal_chr${chr}
  dx download ${project}:/wgs_500k_masks/annotations_utr_chr${chr}
  dx download ${project}:/wgs_500k_masks/set_list_chr${chr}.txt
  dx download ${project}:/wgs_500k_masks/masks_1_chr_${chr}
  dx download ${project}:/wgs_500k_masks/masks_2_chr_${chr}
  dx download ${project}:/wgs_500k_masks/masks_3_chr_${chr}

  #### Windows files
  custom=windows
  dx download ${project}:/wgs_500k_masks/${custom}/${custom}_annotations_regulatory_chr${chr}
  dx download ${project}:/wgs_500k_masks/${custom}/${custom}_set_list_chr${chr}.txt
  dx download ${project}:/wgs_500k_masks/${custom}/${custom}_mask

  # download step 1 files
  dx download ${project}:/proteomics/results/step1/${Phenotype}_Step1* --overwrite
  #mv ${Phenotype}_${type}_${RINT}_Step1_1.loco ${Phenotype}_Step1_1.loco
  mv ${Phenotype}_Step1.list ${Phenotype}_Step1_pred.list
}

mask_setup() {
  # combine windows and regulatory masks
  cat ${custom}_annotations_regulatory_chr${chr} annotations_regulatory_chr${chr} > annotations_regulatory_chr${chr}_2
  # subset to only those units which start within the asked for range
  cat ${custom}_set_list_chr${chr}.txt set_list_chr${chr}.txt | awk -v chr=${chr} -v start=${chrom_start} -v end=${chrom_end} '$2==chr && $3>=start && $3<=end' > set_list_temp

  cat masks_1_chr_${chr} ${custom}_mask > masks_cat
  mv masks_cat masks_1_chr_${chr}
  mv annotations_regulatory_chr${chr}_2 annotations_regulatory_chr${chr}

  cat annotations_regulatory_chr${chr} annotations_coding_proximal_chr${chr} annotations_utr_chr${chr} > annotations_all
  awk '{print $1}' set_list_temp > set_lists_included
  grep -w -f set_lists_included annotations_all | awk '{print $1}' > variants_to_include_masks

  # count total number of sets to run
  n_sets_all=`wc -l set_list_temp | cut -d' ' -f1`

  # separate regulatory and sliding windows from other sets and count them as regenie can only run a maximum number at once, and will fail if there's not at least one mask
  grep -E 'regulatory|sliding|rna' set_list_temp | cat > set_list_only_reg
  echo "reg sets" >> set_list_only_reg
  n_reg_sets=`wc -l set_list_only_reg | cut -d' ' -f1`
  n_reg_sets=$((${n_reg_sets}-1))

  echo $((${n_reg_sets})) " regulatory and sliding window masks"

  grep -E -v 'regulatory|sliding|rna' set_list_temp | cat > set_list_not_reg
  echo "nonreg sets" >> set_list_not_reg
  n_nonreg_sets=`wc -l set_list_not_reg | cut -d' ' -f1`
  n_nonreg_sets=$((${n_nonreg_sets}-1))

  echo $((${n_nonreg_sets})) " coding and proximal-regulatory window masks"

  cat masks_1_chr_${chr} masks_2_chr_${chr} masks_3_chr_${chr} > all_masks
}

setup() {
  #### Make executables work
  chmod 777 *

  #### Make output directory 
  if [ $type == "Continuous" ];then
    if [ "${invnorm}" == "RINT" ]; then
      outputdir=${Phenotype}_rint_burden_wgs
    elif [ "${invnorm}" == "MCC" ]; then
      outputdir=${Phenotype}_mcc_burden_wgs
    else
      outputdir=${Phenotype}_raw_burden_wgs
    fi
  else
    outputdir=${Phenotype}_binary_burden_wgs
  fi
  outputdir_single_var=${outputdir}"/single_variants/"
  outputdir=${outputdir}"/burden/"
  mkdir -p $outputdir
  dx mkdir -p ${project}:proteomics/results/${outputdir}
}

conditional_lists() {
  #Download Conditional List
  dx download ${project}:/proteomics/results/${outputdir_single_var}/${Phenotype}_chr${chr}_*cojo* --overwrite
 
  touch ${Phenotype}_cojo.joint_snps.delete
  if [ ! -f ${Phenotype}_chr${chr}_${range}_conditioned_cojo_mac5_v4.jma.cojo ]; then
  	mv ${Phenotype}_cojo.joint_snps.delete ${Phenotype}_chr${chr}_${range}_conditioned_cojo_mac5_v2.jma.cojo

  else
	cp ${Phenotype}_chr${chr}_${range}_conditioned_cojo_mac5_v4.jma.cojo ${Phenotype}_chr${chr}_${range}_conditioned_cojo_mac5_v2.jma.cojo 
  fi
  grep -v 'Chr' ${Phenotype}_chr${chr}_${range}_conditioned_cojo_mac5_v2.jma.cojo | awk '$5>=0.01 {print $2}' | cat >> conditional_list_common

  # count number of variants asked to condition on and build list for regenie
    grep "${chr}:" conditional_list_common | cat > conditional_list_local
    # add in coding variants

    grep -i coding_${Phenotype}_* annotations_coding_proximal_chr${chr} | cut -f1 | cat > coding_variants


  # count total number of conditional SNPs including single variants from WGS GWAS

  cat <(awk '{print $2}' ${Phenotype}_chr${chr}_${range}_conditioned_cojo_mac5_v2.jma.cojo | grep -v 'Chr' | cat)  conditional_list_local | sort -k1 | uniq | cat > conditional_list_final_temp
  grep "${chr}:" conditional_list_final_temp | cat > conditional_list_final

  #Make master list of variants to include in plink file
  cat variants_to_include_masks conditional_list_final coding_variants  > variants_to_include

  # Make a subset plink file to enable parallel processing
  ./plink2 --pfile chr${chr}_sv_and_snv --prune --1 --extract variants_to_include --pheno Phenotype_TSV --make-pgen --double-id --out chr${chr}_for_regenie


  ## add coding vars to common list 
  grep -wf coding_variants <(grep -v '#' chr${chr}_for_regenie.pvar | cut -f3) | cat > coding_vars_in_pvar
  cat conditional_list_local coding_vars_in_pvar > conditional_list_local_mv
  mv conditional_list_local_mv conditional_list_local
  echo "conditional" >> conditional_list_local
  n_conditional_snps=`wc -l conditional_list_local | cut -d' ' -f1`
  n_conditional_snps=$((${n_conditional_snps}-1))
  grep -wv "conditional" conditional_list_local | cat > conditional_list_local_mv
  mv conditional_list_local_mv conditional_list_local

  ## add coding vars to full list

  cat <(awk '{print $2}' ${Phenotype}_chr${chr}_${range}_conditioned_cojo_mac5_v2.jma.cojo | grep -v 'Chr' | cat)  conditional_list_local | sort -k1 | uniq | cat > conditional_list_final_temp
  grep "${chr}:" conditional_list_final_temp | cat > conditional_list_final

  cat conditional_list_final <(echo "conditional") > conditional_list_final_count
  n_conditional_snps_all=`wc -l conditional_list_final_count | cut -d' ' -f1`
  n_conditional_snps_all=$((${n_conditional_snps_all}-1))


}
